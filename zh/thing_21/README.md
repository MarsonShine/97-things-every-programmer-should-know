# 区分业务异常和技术异常

运行时出错基本上有两个原因：技术问题导致我们无法使用应用程序；业务逻辑导致我们无法滥用应用程序。大多数现代语言（如 LISP、Java、Smalltalk 和 C#）都使用异常来提示这两种情况。然而，这两种情况是截然不同的，因此应小心区分开来。使用相同的异常层次结构来表示这两种情况可能会造成混乱，更不用说使用相同的异常类了。

当出现编程错误时，可能会出现无法解决的技术问题。例如，如果你试图从一个大小为 17 的数组中访问元素 83，那么程序显然偏离了轨道，应该会产生一些异常。更微妙的情况是使用不恰当的参数调用某些库代码，从而导致库内部出现同样的情况。

试图解决这些由自身引起的情况是错误的。相反，我们应该让异常冒泡到最高层次的架构，并让一些通用的异常处理机制尽力确保系统处于安全状态，比如回滚事务、记录和通知管理员，并向用户报告（友好地）。

这种情况的变体是当你处于“库情境”时，调用者违反了你方法的契约，比如传递了完全奇怪的参数或者没有正确设置依赖对象。这与从17个元素中访问第83个元素的情况类似：调用者应该进行检查；不这样做是客户端的程序员错误。正确的响应是引发技术异常。

另一种不同但仍然是技术性质的情况是，程序由于执行环境中的问题（比如数据库无响应）而无法继续执行。在这种情况下，你必须假设基础设施已经尽力解决了问题——修复了连接并在合理的次数内重试——但是失败了。即使原因不同，调用代码的情况也是相似的：它几乎无能为力。因此，我们通过一个异常来表示这种情况，让它冒泡到通用异常处理机制。

与这些情况相反的是，由于领域逻辑原因，你无法完成调用。在这种情况下，我们遇到了一个异常的情况，即不寻常和不希望发生，但不是奇怪或者在程序上错误。例如，如果我试图从余额不足的账户中取款。换句话说，这种情况是契约的一部分，并且抛出异常只是一种**替代的返回路径**，是模型的一部分，客户端应该知道并准备处理它。对于这些情况，创建一个特定的异常或者一个单独的异常层次结构是合适的，以便客户端能够根据自己的需求处理这种情况。

在相同的层次结构中混合技术异常和业务异常会模糊两者之间的区别，并使调用者困惑于方法契约、调用前应该确保的条件以及它应该处理的情况。将这些情况分开会带来清晰度，并增加技术异常将被某些应用程序框架处理，而业务领域异常实际上被客户端代码考虑和处理的机会。

作者：[Dan Bergh Johnsson](http://programmer.97things.oreilly.com/wiki/index.php/Dan_Bergh_Johnsson)