# 别让你的程序僵化

我曾经写过一个拙劣的C++测验，其中讽刺地提到了以下的异常处理策略：

> 通过在我们的代码库中大量使用`try...catch`结构，我们有时能够防止我们的应用中止。我们将其结果状态称为“将尸体钉在竖立的位置上”。

那是在我们自家制作的C++库中的一个基础应用类。多年来，它已经被很多程序员的手操弄得支离破碎：没有人的手是干净的。它包含了处理从其他所有地方逃逸出来的所有异常的代码。从约瑟里安（Catch-22）那里得到启示，我们决定，或者说感觉（*决定*意味着这个怪物的构造比我所思考的要多），这个类的一个实例应该永远活着，或者死于尝试。

为此，我们交织了多个异常处理程序。我们将Windows的结构化异常处理与本地类型（还记得C++中的`__try...__except`吗？我也记不清了）混合在一起。当事情出乎意料地抛出异常时，我们试图再次调用它们，加大参数的压力。回首往事，我喜欢想象，在另一个`try...catch`处理程序的catch子句中编写内部处理程序时，我可能意识到自己可能不小心从良好实践的高速公路上走上了芳香但不健康的疯狂小巷。然而，这可能只是事后的智慧。

不用说，每当基于这个类的应用程序出现问题时，它们就像码头边上的黑手党受害者一样消失，留下没有用的气泡路径，以指示发生了什么鬼东西，尽管我们调用了转储例程来记录灾难。最终——漫长的最终——我们总结了自己的所作所为，并感到羞愧。我们用一个最小化的、强大的报告机制取代了整个混乱的局面。不过，这已经是很多次崩溃之后的事情了。

我不想和你们分享这个经历——因为毕竟没有人会像我们当时那样愚蠢——但最近我和一个他的学术职称声明他应该知道得更多的家伙在网上发生了争论。我们在讨论一个远程事务中的Java代码。如果代码失败，他认为，它应该在原地捕获和阻止异常（“然后与之一起做什么？”我问道，“煮晚餐？”）。

他引用了UI设计师的规则：永远不要让用户看到异常报告，就好像这解决了问题，毕竟它是大写的。我不知道他是否负责过那些蓝屏自动取款机中的代码，而这些自动取款机的照片就装饰在那些孱弱的博客上，他因此受到了永久性的创伤。

无论如何，如果你遇到了他，点头微笑，不要理会，一边悄悄溜向门口。

作者：[Verity Stob](http://programmer.97things.oreilly.com/wiki/index.php/Verity_Stob)