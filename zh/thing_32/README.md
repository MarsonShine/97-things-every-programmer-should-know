# 封装行为，而不仅仅是状态

在系统理论中，封装是处理大型和复杂系统结构时最有用的构造之一。在软件行业，封装或封装性的价值被广泛认知。封装受到编程语言构造的支持，例如子程序和函数、模块和包、类等。

模块和包可以满足更大规模的封装需求，而类、子程序和函数则可以满足更细粒度的封装需求。多年来，我发现类似乎是开发人员最难掌握的封装结构之一。一个类只有一个 3000 行的主方法，或者一个类的原始属性只有 *set* 和 *get* 方法，这种情况并不少见。这些例子表明，相关的开发人员还没有完全理解面向对象的思想，没有充分利用对象作为建模构造的强大功能。对于熟悉 POJO（Plain Old Java Object）和 POCO（Plain Old C# Object 或 Plain Old CLR Object）这两个术语的开发人员来说，这就是回归 OO 作为建模范例的基本原理——对象简单明了，但并不愚蠢。

对象封装了状态和行为，而行为是由实际状态定义的。请看一个门对象。它有四种状态：关闭、打开、正在关闭、正在打开。它提供两种操作：打开和关闭。根据状态的不同，打开和关闭操作的行为也不同。对象的这种固有属性使设计过程在概念上变得简单。它可以归结为两个简单的任务：向不同对象分配和授权责任，包括对象间的交互协议。

实践中，最好用一个例子来说明这个概念。假设我们有三个类：Customer（顾客）、Order（订单）和Item（商品）。Customer对象是存储信用额度和信用验证规则的自然容器。Order对象知道它相关的Customer，并且它的addItem操作通过调用`customer.validateCredit(item.price())`委托实际的信用检查。如果方法的后置条件失败，可以抛出异常并中止购买。

经验较少的面向对象开发人员可能会决定将所有业务规则封装到一个对象中，通常称为`OrderManager`或`OrderService`。在这些设计中，`Order`、`Customer`和`Item`被视为几乎只是记录类型。所有逻辑都从这些类中分离出来，然后在一个大型的过程化方法中用很多内部的*if-then-else*结构将它们联系在一起。这些方法容易出错，几乎无法维护。原因是封装被破坏了。

所以归根结底，不要破坏封装，并且利用编程语言的功能来保持封装性。

作者：[Einar Landre](http://programmer.97things.oreilly.com/wiki/index.php/Einar_Landre)