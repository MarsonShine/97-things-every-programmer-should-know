# 浮点数不是实数

浮点数不是数学意义上的“实数”，尽管在某些编程语言（如 Pascal 和 Fortran）中它们被称为*实数*。实数的精度是无限的，因此是连续的、无损耗的；浮点数的精度是有限的，因此是有限的，它们类似于“行为不良”的整数，因为它们在整个范围内的间距并不均匀。

举例说明，将 2147483647（最大的有符号 32 位整数）赋值给一个 32 位浮点变量（例如 x）并打印出来。你会看到 2147483648。现在打印 x - 64。还是 2147483648。现在打印 x - 65，得到 2147483520！为什么会这样？因为该范围内相邻浮点数之间的间距是 128，而浮点运算四舍五入到最接近的浮点数。

IEEE 浮点数是基于二进制科学记数法的固定精度数： $1.d1d2......d_{p-1}×2^e$，其中 p 是精度（24 表示浮点数，53 表示双倍数）。两个连续数字之间的间距为 $2^{1-p+e}$，可以安全地用 $ε|x|$ 来近似，其中 ε 是 ($2^{1-p}$)。

了解浮点数邻域的间距可以帮助您避免经典的数字错误。例如，如果您正在执行迭代计算，如寻找方程的根，那么在答案附近要求比数字系统所能提供的更高精度是毫无意义的。请确保您要求的公差不小于此处的间距，否则您将永远循环下去。

由于浮点数是实数的近似值，其中必然存在一些误差。这种误差称为舍入误差，可能导致令人吃惊的结果。例如，当你减去几乎相等的数时，最高位数字会相互抵消，因此舍入误差存在的最低有效位（位置在浮点数结果中）会晋升为最高有效位，从而基本上影响了任何与之相关的进一步计算（这种现象称为“涂抹(smearing)”）。你需要仔细审查你的算法，以防止这种灾难性的抵消。举例来说，考虑用二次方程公式求解方程$x² - 100000x + 1 = 0$。由于表达式$-b + sqrt(b² - 4)$中的操作数在幅度上几乎相等，你可以计算根$r₁ = -b + sqrt(b² - 4)$，然后得到$r₂ = 1/r₁$，因为对于任何二次方程$ax² + bx + c = 0$，其根满足$r₁r₂ = c/a$。

涂抹还可能以更微妙的方式发生。假设一个库通过公式 $1 + x + x2/2 + x3/3 + ...$ 天真地计算 $e^x$。这对于正的x值来说是可以的，但是考虑一下当x是一个很大的负数时会发生什么。偶数次幂的项会得到很大的正数，减去奇数次幂的幅度甚至都不会影响结果。问题在于，大的正数项中的舍入误差位于比真实答案更为重要的数字位置。答案向正无穷方向发散！解决这个问题也很简单：对于负的x，计算$e^x = 1/e^{|x|}$。

不言而喻，你不应该在金融应用中使用浮点数——那是 Python 和 C# 等语言中的十进制类的用途。浮点数用于高效的科学计算。但是，如果没有准确性，效率就毫无价值，所以请记住四舍五入错误的来源，并据此编写代码！

作者：[Chuck Allison](http://programmer.97things.oreilly.com/wiki/index.php/Chuck_Allison)