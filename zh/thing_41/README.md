# 进程间通信影响应用程序的响应时间

响应时间对软件的可用性至关重要。很少有事情能像等待某些软件系统的响应时间那样令人沮丧，尤其是当我们与软件的交互涉及到重复的唤起和响应循环时。我们会觉得软件在浪费我们的时间，影响我们的工作效率。然而，响应时间不佳的原因却不那么为人所知，尤其是在现代应用程序中。许多性能管理文献仍将重点放在数据结构和算法上，这些问题在某些情况下会产生影响，但在现代多层企业应用程序中却不太可能主导性能。

当性能成为此类应用程序的问题时，我的经验是，检查数据结构和算法并不是寻求改进的正确途径。响应时间在很大程度上取决于为响应触发而进行的远程进程间通信（IPC）的数量。虽然可能存在其他本地瓶颈，但远程进程间通信的数量通常占主导地位。每一次远程进程间通信都会对整体响应时间造成不可忽略的延迟，这些单独的延迟会累加，尤其是当它们依次发生时。

使用对象关系映射的应用程序中的*波纹加载（ripple loading）*就是一个典型的例子。波纹加载描述了许多数据库调用的顺序执行，以选择构建对象图所需的数据（参见 Martin Fowler 的《企业应用架构模式》*中的[Lazy Load](http://martinfowler.com/eaaCatalog/lazyLoad.html)）。当数据库客户端是渲染网页的中间层应用服务器时，这些数据库调用通常在单个线程中顺序执行。它们各自的延迟会累积起来，导致整体响应时间的增加。即使每次数据库调用只需 10 毫秒，一个需要 1000 次调用的页面（这种情况并不少见）也至少需要 10 秒的响应时间。其他例子包括网络服务调用、来自网络浏览器的 HTTP 请求、分布式对象调用、请求-回复消息传递以及通过自定义网络协议进行的数据网格交互。响应所需的远程 IPC 越多，响应时间就越长。

有几种相对明显和众所周知的策略可以减少每个启动的远程进程间通信次数。其中一种策略是应用 "准化 "原则，优化进程间的接口，从而以最少的交互量交换符合当前目的的正确数据。另一种策略是尽可能实现进程间通信的并行化，使整体响应时间主要由延迟最长的 IPC 驱动。第三种策略是缓存之前 IPC 的结果，这样就可以通过访问本地缓存来避免未来的 IPC。

在设计应用程序时，要注意响应每个进程间通信次数。在分析性能不佳的应用程序时，我经常发现 IPC 与唤起的比率高达数千比一。通过缓存、并行化或其他技术降低这一比率，比改变数据结构选择或调整排序算法更有效。

作者：[Randy Stafford](http://programmer.97things.oreilly.com/wiki/index.php/Randy_Stafford)