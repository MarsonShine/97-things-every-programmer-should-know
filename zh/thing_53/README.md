# 链接器不是神奇的程序

许多程序员对编译语言中从源代码到静态链接可执行文件的过程的看法经常是令人沮丧的（就在我写这篇文章之前，我又遇到了这种情况）：

1. 编辑源代码
2. 将源代码编译成目标文件
3. 神奇的事情发生了
4. 运行可执行文件

第 3 步当然是链接步骤。我为什么会说这么离谱的话？我做了几十年的技术支持，下面这些问题我屡屡遇到：

- 链接器说 def 的定义不止一次。
- 链接器说 abc 是一个未解决的符号。
- 为什么我的可执行文件这么大？

紧接着就是”我现在该怎么办？“，通常还夹杂着”似乎是“和”不知何故“等短语，让人百思不得其解。”似乎“和”不知何故“表明，链接过程被视为一个神奇的过程，大概只有巫师和术士才能理解。编译过程不会引出这类短语，这意味着程序员一般都了解编译器的工作原理，或者至少知道编译器是做什么的。

链接器是一个非常愚蠢、简单、直接的程序。它所做的只是将目标文件的代码和数据部分连接在一起，将符号引用与其定义连接起来，将未解决的符号从库中提取出来，然后写出一个可执行文件。就是这样。没有咒语！没有魔法 编写链接器的繁琐之处通常在于解码和生成通常复杂得令人发指的文件格式，但这并不能改变链接器的本质。

比方说，链接器认为 def 的定义不止一次。许多编程语言，如 C、C++ 和 D，都有声明和定义。声明通常放在头文件中，例如

```
extern int iii；
```

会产生对符号 `iii` 的外部引用。另一方面，定义实际上是为符号预留存储空间，通常出现在实现文件中，看起来像这样：

```
int iii = 3；
```

每个符号可以有多少个定义？就像电影*Highlander*中那样，只能有一个。那么，如果 iii 的定义出现在多个实现文件中怎么办？

```
// 文件 a.c
int iii = 3；
```

```
// 文件 b.c
double iii(int x) { return 3.7; }
```

链接器会抱怨 `iii` 被多重定义。

不仅只能有一个，而且必须有一个。如果 iii 只作为声明而不是定义出现，链接器将抱怨 iii 是一个未解决的符号。

要确定可执行文件的大小，可以查看链接器可选择生成的映射文件。映射文件只不过是可执行文件中所有符号及其地址的一个列表。这将告诉你哪些模块是从库中链接进来的，以及每个模块的大小。现在，你可以知道臃肿的原因了。通常会有一些你不知道为什么会链接进来的库模块。要找出原因，可以暂时将可疑模块从库中删除，然后重新链接。随后产生的未定义符号错误将表明谁在引用该模块。

虽然并不总是能立即看出为什么会收到特定的链接器信息，但链接器并没有什么神奇之处。其原理是简单明了的，关键是在每种情况下都要弄清楚细节。

作者：[Walter Bright](http://creativecommons.org/licenses/by/3.0/us/)