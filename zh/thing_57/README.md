# 消息传递可提高并行系统的可扩展性

程序员从学习计算机的一开始就被告知，并发--尤其是并行（并发的一个特殊子集）--是很难的，只有最优秀的程序员才有希望把它做对，即使他们也会出错。人们总是把注意力集中在线程、信号、监控器上，以及让并发访问变量的线程安全是多么困难。

的确，有很多难题，而且很难解决。但问题的根源是什么呢？共享内存。人们喋喋不休地讨论的几乎所有并发问题都与共享可变内存的使用有关：竞争条件、死锁、活锁等。答案似乎显而易见：要么放弃并发，要么放弃共享内存！

放弃并发几乎肯定是不可能的。计算机的内核几乎每个季度都在增加，因此利用真正的并行性变得越来越重要。我们不能再依靠不断提高处理器时钟速度来提高应用性能。只有利用并行性，才能提高应用程序的性能。显然，不提高性能也是一种选择，但用户不可能接受。

那么，我们可以放弃共享内存吗？当然可以。

我们可以使用进程和消息传递来代替线程和共享内存作为编程模型。这里的进程指的是一个受保护的、独立的、正在执行代码的状态，而不一定是操作系统进程。Erlang 等语言（以及之前的 occam）已经证明，进程是一种非常成功的并发和并行系统编程机制。这些系统并不像共享内存、多线程系统那样具有同步压力。此外，还有一种形式化模型--通信顺序进程（CSP）--可以作为此类系统工程的一部分加以应用。

我们可以更进一步，将数据流系统作为一种计算方式引入。在数据流系统中，没有明确编程的控制流。取而代之的是建立一个由数据路径连接的操作符有向图，然后将数据输入系统。评估由系统内数据的准备情况控制。绝对没有同步问题。

综上所述，C、C++、Java、Python 和 Groovy 等语言是系统开发的主要语言，所有这些语言都是作为开发共享内存、多线程系统的语言呈现给程序员的。那么有什么办法呢？答案是使用提供进程模型和消息传递的库和框架，如果不存在这些库和框架，则创建它们，避免使用所有共享可变内存。

总而言之，不使用共享内存编程，而是使用消息传递，很可能是实现利用并行性的系统的最成功方法，而并行性正是计算机硬件的特性。也许奇怪的是，虽然进程作为并发单元的出现早于线程，但未来似乎是使用线程来实现进程。

作者：[Russel Winder](http://programmer.97things.oreilly.com/wiki/index.php/Russel_Winder)