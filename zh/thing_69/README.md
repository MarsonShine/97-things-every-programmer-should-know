# 放下鼠标，远离键盘

你已经花了几个小时专注于某个棘手的问题，但却看不到任何解决方案。于是你起身去伸伸腿，或者去自动售货机买点东西，在回来的路上，答案突然变得显而易见。

这种情况听起来熟悉吗？有没有想过为什么会出现这种情况？诀窍在于，当你在编码时，大脑的逻辑部分处于活跃状态，而创造性部分则被拒之门外。在逻辑部分休息之前，它无法向你展示任何东西。

下面是一个真实的例子：我在清理一些遗留代码时遇到了一个“有趣”的方法。它的目的是验证字符串是否包含有效的时间，格式为 *hh:mm:ss xx*，其中 *hh* 代表小时，*mm* 代表分钟，*ss* 代表秒，*xx* 是 *AM* 或 *PM*。

该方法使用以下代码将两个字符（代表小时）转换成数字，并验证其是否在适当的范围内：

```java
try {
    Integer.parseInt(time.substring(0, 2))；
} catch (Exception x) {
    return false；
}

if (Integer.parseInt(time.substring(0, 2)) > 12) {
    返回 false；
}
```

同样的代码又出现了两次，对字符偏移和上限作了适当修改，以测试分钟和秒钟。该方法的最后一行是检查上午和下午：

```
if (!time.substring(9, 11).equals("AM") &
    !time.substring(9, 11).equals("PM")) {
    返回 false；
}
```

如果这一系列比较都没有失败，返回 false，否则该方法返回 true。

如果前面的代码看起来冗长难懂，不用担心。我也是这么想的--这意味着我发现了一些值得清理的地方。我对它进行了重构，并编写了一些单元测试，以确保它仍然有效。

完成后，我对结果很满意。新版本易于阅读，大小只有原来的一半，而且更加准确，因为原来的代码只测试了小时、分钟和秒的上边界。

第二天准备上班时，我突然想到了一个主意：为什么不用正则表达式验证字符串呢？输入几分钟后，我只用一行代码就实现了。就是这样：

```
public static boolean validateTime(String time) {
    return time.matches("(0[1-9]|1[0-2]):[0-5][0-9]:[0-5][0-9] ([AP]M)");
}
```

这个故事的重点不在于我最终只用一行代码替换了三十多行代码。重点是，在我离开电脑之前，我一直认为我的第一次尝试是解决问题的最佳方案。

所以，下次遇到棘手问题时，请帮自己一个忙。一旦你真正理解了问题，就去做一些涉及大脑创造力的事情--画出问题的草图，听一些音乐，或者只是到外面散散步。有时，你能做的解决问题的最好办法就是放下鼠标，远离键盘。

作者：[BurkHufnagel](http://programmer.97things.oreilly.com/wiki/index.php/BurkHufnagel)