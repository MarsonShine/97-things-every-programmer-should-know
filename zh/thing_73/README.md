# 抵制单例模式的诱惑

单例模式解决了你的许多问题。你知道你只需要一个实例。你可以保证在使用该实例之前对其进行初始化。通过一个全局访问点，它可以使你的设计保持简单。这一切都很好。这种经典的设计模式有什么不好呢？

事实证明，有很多。它们可能很诱人，但经验表明，大多数单例弊大于利。它们妨碍了可测试性，损害了可维护性。遗憾的是，这种额外的智慧并没有得到应有的普及，单例仍然是许多程序员无法抗拒的诱惑。但这是值得抵制的：

- 单例要求往往是想象出来的。在许多情况下，未来不需要额外的实例纯属猜测。在应用程序的设计中散布这种推测属性，在某些时候必然会带来痛苦。需求是会变化的。好的设计会考虑到这一点。而单例不会。

- 单例会导致概念上独立的代码单元之间产生隐含的依赖关系。这是一个问题，因为它们是隐藏的，也因为它们在单元之间引入了不必要的耦合。当你尝试编写单元测试时，这种代码气味就会变得刺鼻，因为单元测试依赖于松散的耦合以及选择性地用模拟实现替代真实实现的能力。单例阻止了这种直接的模拟。

- 单例还携带隐式持久状态，这再次阻碍了单元测试。单元测试依赖于测试之间的相互独立，因此测试可以按照任意顺序运行，程序也可以在执行每个单元测试之前设置为已知状态。一旦引入了状态可变的单例，这可能就很难实现了。此外，这种全局可访问的持久状态会增加代码推理的难度，尤其是在多线程环境中。

- 多线程给单例模式带来了更多隐患。由于直接锁定访问并不高效，所谓的双重检查锁定模式（DCLP）越来越受欢迎。不幸的是，这可能是另一种形式的致命吸引力。事实证明，在许多语言中，DCLP 都不是线程安全的，即使是线程安全的，也有可能出现微妙的错误。

单例的清理可能是最后一个挑战：

- 目前还不支持显式杀死单例，这在某些情况下可能是一个严重的问题。例如，在插件架构中，只有在清理完所有对象后才能安全卸载插件。

- 在程序退出时，单例的隐式清理没有顺序可言。对于包含相互依赖的单例的应用程序来说，这可能会带来麻烦。在关闭此类应用程序时，一个单例可能会访问另一个已被销毁的单例。

- 这些缺陷中的一些可以通过引入额外的机制来克服。但是，这样做的代价是增加代码的复杂性，而这些复杂性本可以通过选择其他设计来避免。

因此，请将单例模式的使用范围限制在真正必须永远不被实例化一次以上的类上。不要在任意代码中使用单例的全局访问点。相反，应该只在少数几个定义明确的地方直接访问单例，在这些地方可以通过接口将单例传递给其他代码。其他代码并不知晓，因此不会依赖于单例或任何其他类型的类是否实现了接口。这就打破了妨碍单元测试的依赖关系，提高了可维护性。所以，下次当你考虑实现或访问单例时，希望你能暂停一下，再考虑一下。

作者：[Sam Saariste](http://programmer.97things.oreilly.com/wiki/index.php/Sam_Saariste)