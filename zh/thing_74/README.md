# 通往性能之路充满脏代码爆炸

调整系统性能往往需要修改代码。当我们需要修改代码时，每一个过于复杂或高度耦合的代码块都是一个肮脏的代码炸弹，埋伏在那里，随时准备破坏我们的工作。脏代码的第一个受害者将是你的日程安排。如果前进的道路是平坦的，就很容易预测何时完成。如果意外遭遇脏代码，就很难做出合理的预测。

考虑一下发现执行热点的情况。通常的做法是降低底层算法的强度。比方说，你在回复经理的估算请求时，得到的答案是 3-4 小时。当你进行修复时，你很快就会意识到你已经破坏了一个从属部分。由于密切相关的事物通常必然是耦合的，因此这种损坏很可能是预料之中并已考虑到的。但是，如果修复该依赖关系会导致其他依赖部分损坏，会发生什么情况呢？此外，依赖关系离原点越远，你就越不可能意识到它的存在，并在估算中加以考虑。突然之间，3-4 小时的估算时间很容易膨胀到 3-4 周。通常情况下，计划表中这种意想不到的膨胀每次发生1或2天。“快速”重构最终需要几个月才能完成，这种情况并不少见。在这些情况下，对负责团队的信誉和政治资本的损害将从严重到彻底。如果我们有一个工具来帮助我们识别和衡量这种风险就好了。

事实上，我们有很多方法来测量和控制耦合的程度和深度以及代码的复杂性。软件度量可以用来计算代码中特定特性的出现次数。这些计数的值确实与代码质量相关。许多度量耦合的指标中有两个是扇入和扇出。考虑类的扇形输出：它被定义为直接或间接从感兴趣的类引用的类的数量。您可以将其视为在编译类之前必须编译的所有类的计数。另一方面，扇入是依赖于感兴趣的类的所有类的计数。知道扇出和扇入，我们可以使用*I = f<sub>o</sub> / (f<sub> I </sub> + f<sub>o</sub>)*来计算不稳定因子。当*I*趋近于0时，包变得更加稳定。当*I*接近1时，包变得不稳定。稳定的包是重新编码的低风险目标，而不稳定的包更有可能被肮脏的代码炸弹所填充。重构的目标是使*I*更接近于0。

当使用指标时，必须记住它们只是经验法则。纯粹从数学角度来看，我们可以看到增加*f<sub>i</sub>*而不改变fo将使*I*更接近于0。然而，非常大的扇入值有一个缺点，即在不破坏依赖项的情况下更改这些类将更加困难。此外，如果不解决扇形问题，你就不能真正降低风险，所以必须采取一些平衡措施。

软件指标的一个缺点是，指标工具产生的大量数字可能会吓到外行人。也就是说，软件度量可以成为我们争取干净代码的强大工具。它们可以帮助我们在脏代码爆炸对性能调优练习构成严重风险之前识别并消除它们。

作者：[Kirk Pepperdine](http://programmer.97things.oreilly.com/wiki/index.php/Kirk_Pepperdine)