# 为必需行为而非附带行为编写测试

在测试中的一个常见陷阱是假设实现的确切行为就是你想要测试的内容。乍一看，这听起来更像是一种优点而非陷阱。但如果换个角度来看，问题就显而易见了：在测试中的一个常见陷阱是将测试与实现的具体细节硬编码绑定在一起，而这些细节是次要的，与期望的功能无关。

当测试与实现的次要细节硬编码绑定时，对实现的变更可能是与所需行为兼容的，但这样的变更可能导致测试失败，产生虚假的正面结果。程序员通常会采取两种方式来应对：要么重写测试，要么重写代码。假设虚假的正面结果实际上是真实的正面结果通常是因为恐惧、不确定性或疑虑。这样做的结果是将次要行为的地位提升到必需行为的地步。在重写测试时，程序员要么将测试重新聚焦到必需行为上（好的做法），要么只是将其硬编码到新的实现上（不好的做法）。测试需要足够精确，但也需要准确。

例如，在三路比较中，比如C语言的 `strcmp` 或Java的 `String.compareTo`，对结果的要求是，如果左操作数小于右操作数，则结果为负数，如果左操作数大于右操作数，则结果为正数，如果它们被视为相等，则结果为零。这种比较方式在许多API中都有使用，包括C语言的 `qsort` 函数的比较器和Java的 `Comparable` 接口的 `compareTo` 方法。虽然具体的值 `-1` 和 `+1` 在实现中通常用来表示*小于*和*大于*，但程序员经常错误地假设这些值代表了实际的要求，从而编写将这种假设公之于众的测试。

类似的问题也出现在那些断言间距、精确措辞以及文本格式和表现形式的其他偶然方面的测试中。例如，除非您编写的 XML 生成器提供了可配置的格式，否则间距对结果的影响不大。同样，硬连接用户界面控件上按钮和标签的位置也会减少将来更改和完善这些附带内容的可能性。实现过程中的微小变化和格式上的无关紧要的变化会突然成为构建的障碍。

过于详细规定的测试通常是白盒单元测试方法的问题。白盒测试使用代码的结构确定所需的测试用例。白盒测试的典型失败模式是，测试最终断言代码确实做了代码应该做的事情。简单地重述代码已经明显的功能并不增加任何价值，反而会产生虚假的进步感和安全感。

要使测试有效，测试就必须说明合同义务，而不是鹦鹉学舌。测试需要从黑盒子的角度来看待被测单元，以可执行的形式勾勒出接口契约。因此，要使测试行为与要求行为保持一致。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)