# 精确、具体地测试

重要的是要测试一个代码单元所需的基本行为，而不是测试其特定实现的附带行为。但这不应被视为或误认为是模糊测试的借口。测试既要准确*又*要精确。

排序例程是一个屡试不爽、久经考验的测试经典，它就是一个很好的例子。对于程序员来说，实现排序算法并不一定是一项日常任务，但排序是一个如此熟悉的概念，以至于大多数人都认为他们知道该从排序中期待什么。然而，这种偶然的熟悉感会让人更难看清某些假设。

当程序员被问及“你会测试什么？”时，最常见的回答是“排序的结果是元素的排序序列”。虽然这是事实，但并非真理的全部。当被要求提供更精确的条件时，许多程序员会补充说，结果序列的长度应与原始序列相同。这虽然正确，但仍然不够。例如，给出以下序列：

```
3 1 4 1 5 9
```

下面的序列满足一个后置条件，即按非降序排序，且长度与原始序列相同：

```
3 3 3 3 3 3
```

尽管这符合规范，但这绝对不是原本的意图！这个例子是基于一个来自实际生产代码的错误（幸运的是在发布之前被发现），在那里，一个简单的按键错误或者短暂的疏忽导致了一个复杂的机制，用来用给定数组的第一个元素填充整个结果。

完整的后置条件是结果是排序过的，并且它持有原始值的排列组合。这适当地限制了所需的行为。结果的长度与输入的长度相同，这一点无需重述。

即使以上述方式说明了后置条件，也不足以给出一个好的测试。一个好的测试应该是可读的。它应该易懂、简单，让你一眼就能看出它是正确的（或不正确的）。除非你已经有了检查序列是否排序以及一个序列是否包含另一个序列中值的排列的代码，否则测试代码很可能比被测代码更复杂。正如托尼-霍尔（Tony Hoare）所观察到的：

> 构建软件设计有两种方法： 一种方法是让设计简单到*明显*没有缺陷，另一种方法是让设计复杂到没有明显缺陷。

使用具体的例子可以消除这种意外的复杂性和意外的机会。例如，给出以下序列：

```
3 1 4 1 5 9
```

排序结果如下：

```
1 1 3 4 5 9
```

没有其他答案。不接受任何替代答案。

具体的例子有助于以一种易懂、明确的方式来说明一般性的行为。将项添加到空集合的结果不仅仅是它不再为空：它意味着集合现在有了一个单独的项。而且，这个单独的项就是被添加的项。两个或更多的项将被视为非空。而这也是错误的。不同值的单个项也是错误的。将行添加到表中的结果不仅仅是表多了一行。它还意味着可以使用行的键来检索添加的行。等等。

在指定行为时，测试不仅要准确，还必须精确： 它们还必须精确。

作者：[Kevlin Henney](http://programmer.97things.oreilly.com/wiki/index.php/Kevlin_Henney)