# 利用示例编写小函数

我们希望编写的代码是正确的，并有证据证明它是正确的。考虑函数的“大小”有助于解决这两个问题。这不是指实现函数的代码量——尽管这很有趣——而是指我们的代码所体现的数学函数的大小。

例如，在围棋比赛中，有一种情况叫做 "atari"，在这种情况下，棋手的棋子可能会被对手吃掉：有两个或更多空位（称为 "liberties"）相邻的棋子不在 "atari "中。计算一颗棋子有多少自由空间（即有多少种走法）可能很棘手，但如果知道了这一点，确定 atari 就很容易了。我们可以先写一个这样的函数：

```
boolean atari(int libertyCount)
    libertyCount < 2
```

这比它看起来的要大。数学函数可以理解为一个集合，是作为其域（此处为 int）和范围（此处为 bool）的集合的笛卡尔乘积的某个子集。如果这些值集的大小与 Java 中的相同，那么 int×boolean 集合中将有 `2L*（Integer.MAX_VALUE+(-1L*Integer.MIN_VALUE)+1L）`或  8,589,934,592 个成员。其中有一半是我们的函数子集中的成员，因此要完整证明我们的函数是正确的，我们需要检查约 4.3×109 个示例。

这就是“测试无法证明不存在错误”这一说法的实质。不过，测试可以证明功能的存在。但我们仍然面临着规模问题。

问题域可以帮我们解决这个问题。围棋的本质意味着棋子的自由度数不是任何 int，而是 {1,2,3,4} 中的一个。因此我们也可以写成：

```
LibertyCount = {1,2,3,4} 
boolean atari(LibertyCount libertyCount)
    libertyCount == 1
```

这样就简单多了：现在计算出的函数是一个最多有八个成员的集合。事实上，四个经过检查的例子就可以完全确定函数是正确的。这就是为什么使用与问题领域密切相关的类型而不是本地类型来编写程序是个好主意的原因之一。使用受领域启发的类型通常可以使我们的函数更小。找出这些类型的方法之一，就是在编写函数之前，找到可以用问题域术语检查的示例。

作者：[Keith Braithwaite](http://programmer.97things.oreilly.com/wiki/index.php/Keith_Braithwaite)